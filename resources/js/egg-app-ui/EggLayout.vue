<script setup lang="ts">

import Egg from "@/egg-app-ui/Egg.vue";
import Header from "@/egg-app-ui/header.vue";
import axios from "axios";
import { onMounted, ref, watchEffect } from "vue";
import TabBar from "@/egg-app-ui/tab-bar.vue";

const props = defineProps({
    data: {
        type: Object,
        default: () => ({}),
    },
});

const loveClickCount = ref(0);
const temperatureClickCount = ref(0);
const love = ref(props.data.egg.love);
const temperature = ref(props.data.egg.temperature);
const containerRef = ref<HTMLElement | null>(null);

watchEffect(() => {
    if (love.value > 50 && temperature.value > 50) {
        axios.post('/stage-one', {})

    }
    if (love.value === 100 && temperature.value === 100) {
        axios.post('/stage-two', {})
    }
});

const updateLove = async () => {
    loveClickCount.value++;

    if (loveClickCount.value >= 10) {
        const response = await axios.post('/click-increase-update-love', {});
        love.value = response.data.love;
        loveClickCount.value = 0; // Reset after sending
    }
};

const updateTemp = async () => {
    temperatureClickCount.value++;

    if (temperatureClickCount.value >= 10) {
        const response = await axios.post('/click-increase-update-temperature', {});
        temperature.value = response.data.temperature;
        temperatureClickCount.value = 0; // Reset after sending
    }
};

const decrementLove = async () => {
    if (love.value > 0) {
        const response = await axios.post(route('decrease-update-love'), {});

        love.value = response.data.love;
    }
};

const decrementTemperature = async () => {
    if (temperature.value > 0) {
        const response = await axios.post(route('decrease-update-temperature'), {});

        temperature.value = response.data.temperature;
    }
};

const setCheckContainerBounds = (spongeRef: HTMLElement) => {
    containerRef.value = document.getElementById('container') as HTMLElement;
    const rectOfContainer = containerRef.value.getBoundingClientRect();

    containerRef.value.addEventListener('mousemove', (e: MouseEvent) => {
        const spongeEl = spongeRef as HTMLElement;

        const x = e.clientX;
        const y = e.clientY;

        const spongeWidth = spongeEl.offsetWidth;
        const spongeHeight = spongeEl.offsetHeight;

        // Plaats de spons gecentreerd onder de cursor
        const mouseX = e.clientX - spongeWidth / 2;
        const mouseY = e.clientY - spongeHeight / 2;

        const futureRect = {
            x: mouseX,
            y: mouseY,
            width: spongeWidth,
            height: spongeHeight
        };

        // Controleer of de spons binnen de container blijft
        const isInsideContainer = !(
            futureRect.x > rectOfContainer.x + rectOfContainer.width ||
            futureRect.x + futureRect.width < rectOfContainer.x ||
            futureRect.y > rectOfContainer.y + rectOfContainer.height ||
            futureRect.y + futureRect.height < rectOfContainer.y
        );

        if (isInsideContainer) {
            spongeEl.style.transform = `translate(${mouseX}px, ${mouseY}px)`;
        }



        // Detecteer overlapping met vuil
        const followerRect = spongeEl.getBoundingClientRect();
        document.querySelectorAll('.dirt').forEach((dirtEl: Element) => {
            const dirtRect = dirtEl.getBoundingClientRect();

            if (isRectOverlap(followerRect, dirtRect)) {
                dirtEl.addEventListener('click', () => {
                    dirtEl.remove();
                }, { once: true }); // voorkomt dubbele event listeners
            }
        });
    });

    // Hulpfunctie om rechthoekoverlap te detecteren
    function isRectOverlap(rect1: DOMRect, rect2: DOMRect): boolean {
        return !(
            rect1.x + rect1.width <= rect2.x ||
            rect2.x + rect2.width <= rect1.x ||
            rect1.y + rect1.height <= rect2.y ||
            rect2.y + rect2.height <= rect1.y
        );
    }

}


onMounted(() => {
    const loveInterval = setInterval(() => {
        decrementLove();
    }, 10000);
    const temperatureInterval = setInterval(() => {
        decrementTemperature();
    }, 10000);

    watchEffect(() => {
        return () => {
            clearInterval(loveInterval);
            clearInterval(temperatureInterval);
        };
    });
});
</script>

<template>
    <Header :love="love" :temperature="temperature" :data="data" />
    <div id="container" class="h-full w-full flex items-center justify-center">
        <Egg :temperature="temperature" @eggClicked="updateLove" @poopDamage="decrementLove"/>
    </div>
    <TabBar @sponge-spawned="setCheckContainerBounds" @tempClicked="updateTemp" />
</template>
